%!TEX root = ../ENTRUST_TR.tex
ActivFORMS is a formal approach for self-adaptation that uses an integrated formal model of the adaptive components and knowledge models. The formal model is executed directly by a virtual machine to realize adaptation, hence called active model. ActivFORMS approach distinguishes itself for existing approaches in two ways. First, the formally verified model of the complete feedback loop is directly executed by the virtual machine, which guarantees the verified adaptation goals at runtime. As the active model is directly executed by ActivFORMS, the approach does not require coding. Second, ActivFORMS supports dynamic change of the active model. A new feedback loop model can be deployed at runtime to meet new or changing goals. 

\begin{figure*}[t!]
	\centering
	\includegraphics[width=0.7\textwidth]{figures/ActivFORMS-approach.png}
	\caption{ActivFORMS approach}\label{fig:activforms}
\end{figure*}

Fig.~\ref{fig:activforms} shows the primary modules of the ActivFORMS. The approach is in line with the three layered reference model for self-adaptive systems proposed by Kramer and Magee~\cite{kramer2007sms}. The managed system realizes the domain functionality for users. 
The active model consists of two parts: an integrated formal model that realize a feedback loop, i.e., the active model, and a virtual machine that can execute the active model. The active model monitors the managed system through probes and adapt the managed system through effectors. 

ActivFORMS supports feedback loops modeled using networks of timed automata~\cite{Alur1990}. A timed automaton is a finite-state machine that models a behavior, extended with clock variables. Automata can synchronize through channels. There are two types of channels, binary channels and broadcast channels. For a binary channel, a sender x! can synchronize with a receiver x? through a signal. If there are multiple receivers x? then a single receiver will be chosen non-deterministic. The sender x! will be blocked if there is no receiver. A broadcast channel sends a signal to all the receivers, and if there is no receiver, the sender will not be blocked. Behavior specifications can be complemented with expressions specified in a C-like language to define data structures (struct concept) and functions. Goals can be expressed in timed computation tree logic expressions (TCTL). TCTL expressions describe the state and path formulae that can be verified, such as reachability (a system should/can/cannot/... reach a particular state or set of states), liveness (something eventually will hold), etc. We use Uppaal~\cite{Behrmann2004}, a model checking tool that supports modeling of behaviors and verification of properties.

The goal management layer handles adaptation issues that cannot be performed by the current active model. The goal management consists of four parts, i.e., goal model, goal monitor, goal adapter and goal manager. The goal model represents the adaptation goals. ActivFORMS uses AND-OR tree-based goal model to specify goals. The goals can be expressed as boolean expressions, and the goals at the bottom level of each subtree have associated models to realize adaptations. The goal monitor monitors the status of the goals and if any goal is violated it notifies the goal adapter. The goal adapter is the heart of goal management. When the goal adapter is signaled by the goal monitor about a change of goals, it consults the goal model and search for a matching model that satisfies the changing situation. If the model associated with the changing goal differs from the currently deployed model, the goal adapter starts updating the current model with the new model at the virtual machine. If the model does not differ no further action is required. The goal manager offers support for three primary functions: inspecting the active model and its ongoing execution, monitoring and updating goals, and updating the goal model. In our current implementation, the ActivFORMS User Interface connects with the goal managers of the different nodes of the system. The user interface enables the system admin (or engineer) to perform the functions of the goal managers remotely.
